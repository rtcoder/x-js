{"version":3,"file":"index.umd.js","sources":["../src/bindings/bind.ts","../src/bindings/nested-value.ts","../src/bindings/bind-text.ts","../src/reactive-handler.ts","../src/features/x-for.ts","../src/features/x-if.ts","../src/bindings/bind-elements.ts","../src/main.ts"],"sourcesContent":["/**\n *\n * @param {object} proxy\n * @param {Map} bindings\n * @return {(function(key:string, element:HTMLElement): void)}\n */\nfunction getBindMethod(proxy: any, bindings: Map<any, any>) {\n  /**\n   * @property {string} key\n   * @property {HTMLElement} element\n   */\n  return (key:string, element:any) => {\n    if (!bindings.has(key)) {\n      bindings.set(key, []);\n    }\n    bindings.get(key).push(element);\n\n    // Synchronizacja początkowa\n    if (element.type === 'checkbox') {\n      element.checked = proxy[key];\n    } else if (element.type === 'radio') {\n      element.checked = element.value === proxy[key];\n    } else {\n      element.value = proxy[key];\n    }\n\n    // DOM to model\n    element.addEventListener('input', () => {\n      if (element.type === 'checkbox') {\n        proxy[key] = element.checked;\n      } else if (element.type === 'radio') {\n        if (element.checked) proxy[key] = element.value;\n      } else {\n        proxy[key] = element.value;\n      }\n    });\n\n    // Obsługa select\n    if (element.tagName === 'SELECT') {\n      element.addEventListener('change', () => {\n        proxy[key] = element.value;\n      });\n    }\n  };\n}\n\nexport {getBindMethod};\n","import {bindModelToTextContent} from './bind-text';\n\nfunction getNestedValue(model:any, path:string) {\n  return path.split('.').reduce((acc, part) => acc && acc[part], model);\n}\n\nfunction setNestedValue(model:any, path:string, value:any) {\n  const parts = path.split('.');\n  let current = model;\n\n  // Idziemy do ostatniego elementu w ścieżce\n  for (let i = 0; i < parts.length - 1; i++) {\n    current = current[parts[i]];  // Przechodzimy po zagnieżdżonych obiektach\n  }\n\n  // Teraz aktualizujemy wartość właściwości w ostatnim obiekcie\n  const lastKey = parts[parts.length - 1];\n  if (current) {\n    current[lastKey] = value;\n    model[lastKey] = value;\n  }\n\n  bindModelToTextContent(model);\n}\n\nexport {getNestedValue, setNestedValue};\n","import {getNestedValue} from './nested-value';\n\nfunction bindModelToTextContent(model:any) {\n  document.querySelectorAll('*').forEach((el) => {\n    if (el.tagName === 'SCRIPT') {\n      return;\n    }\n    if (el.childNodes.length === 1 && el.childNodes[0].nodeType === Node.TEXT_NODE) {\n      model.bindText(el);\n    }\n  });\n}\n\n/**\n *\n * @param {object} proxy\n * @param {Map} textBindings\n * @return {(function(el:HTMLElement): void)}\n */\nfunction getBindTextMethod(proxy:any, textBindings:Map<any, any>) {\n  /**\n   * @property {HTMLElement} el\n   */\n  return (el:any) => {\n    const xModelAttr = el.getAttribute('x-model');\n    if (!xModelAttr) {\n      if (!el.dataset.originalContent) {\n        el.dataset.originalContent = el.textContent;\n      }\n    } else {\n      el.dataset.originalContent = `{${xModelAttr}}`;\n    }\n    const originalText = el.dataset.originalContent;\n\n    // Szukaj wzorców {key}\n    const matches = originalText.match(/{\\s*[\\w.]+\\s*}/g);\n    if (matches) {\n      const updateText = () => {\n        // Aktualizujemy tekst, uwzględniając zagnieżdżone właściwości\n        el.textContent = originalText.replace(/{\\s*([\\w.]+)\\s*}/g, (_:string, key:string) => {\n          return getNestedValue(proxy, key.trim()) || '';\n        });\n      };\n\n      // Zarejestruj każdą kluczową właściwość\n      matches.forEach((match:string) => {\n        const key = match.replace(/[{}]/g, '').trim();\n        if (!textBindings.has(key)) {\n          textBindings.set(key, []);\n        }\n        textBindings.get(key).push(updateText);\n      });\n      updateText();\n    }\n  };\n}\n\nexport {getBindTextMethod, bindModelToTextContent};\n","import {getBindMethod} from './bindings/bind';\nimport {getBindTextMethod} from './bindings/bind-text';\n\n/**\n *\n * @param {object} data\n * @return {object|any|boolean}\n */\nfunction reactive(data: any) {\n  const bindings = new Map(); // Powiązania inputów\n  const textBindings = new Map(); // Powiązania tekstów w DOM\n\n  const handler = {\n    get(target: any, key: any) {\n      return Reflect.get(target, key);\n    },\n    set(target: any, key: any, value: any) {\n      const success = Reflect.set(target, key, value);\n\n      // Zaktualizuj powiązane inputy\n      if (bindings.has(key)) {\n        bindings.get(key).forEach((el: any) => {\n          if (el.type === 'checkbox') {\n            el.checked = value;\n          } else if (el.type === 'radio') {\n            el.checked = el.value === value;\n          } else {\n            el.value = value;\n          }\n        });\n      }\n\n      // Zaktualizuj powiązane teksty\n      if (textBindings.has(key)) {\n        textBindings.get(key).forEach((updateText: any) => updateText());\n      }\n\n      // Sprawdź zagnieżdżone obiekty i aktualizuj je w razie potrzeby\n      if (key.includes('.')) {\n        const nestedKeys = key.split('.');\n        let nestedModel = target;\n        for (let i = 0; i < nestedKeys.length - 1; i++) {\n          nestedModel = nestedModel[nestedKeys[i]];\n        }\n        const nestedKey = nestedKeys[nestedKeys.length - 1];\n        if (nestedModel && nestedModel.hasOwnProperty(nestedKey)) {\n          nestedModel[nestedKey] = value;\n        }\n      }\n\n      return success;\n    },\n  };\n\n  const proxy = new Proxy(data, handler);\n\n  proxy.bind = getBindMethod(proxy, bindings);\n  proxy.bindText = getBindTextMethod(proxy, textBindings);\n\n  return proxy;\n}\n\nexport {reactive};\n","import {bindElements} from '../bindings/bind-elements.ts';\nimport {reactive} from '../reactive-handler';\n\n/**\n *\n * @param {Document|HTMLElement} parent\n * @param model\n * @return void\n */\nfunction handleXFor(parent:any, model:any) {\n  parent.querySelectorAll('[x-for]').forEach((el:any) => {\n    const expression = el.getAttribute('x-for');\n    const [itemKey, arrayKey] = expression.split(' in ').map((str:string) => str.trim());\n    const placeholder = document.createComment(`x-for=\"${expression}\"`);\n    el.parentNode.insertBefore(placeholder, el);\n    el.parentNode.removeChild(el);\n\n    const updateList = () => {\n      const items = model[arrayKey] || [];\n\n      // Usuwamy poprzednie elementy (poza placeholderem)\n      let nextNode = placeholder.nextSibling;\n      while (nextNode && nextNode.nodeType !== Node.COMMENT_NODE) {\n        const currentNode = nextNode;\n        nextNode = currentNode.nextSibling;\n        currentNode.remove();\n      }\n\n      // Renderujemy elementy w porządku tablicy\n      items.forEach((item:any) => {\n        const localModel = reactive({[itemKey]: item});\n        const clone = el.cloneNode(true);  // Tworzymy nową kopię elementu\n        clone.removeAttribute('x-for');  // Usuwamy atrybut x-for\n\n        // Wstawiamy elementy w odpowiedniej kolejności\n        placeholder.parentNode?.appendChild(clone);\n\n        // Bindowanie modelu dla każdego elementu\n        bindElements(localModel, placeholder.parentNode);\n      });\n    };\n\n    updateList();\n  });\n}\n\nexport {handleXFor};\n","/**\n *\n * @param {Document|HTMLElement} parent\n * @param model\n * @return void\n */\nfunction handleXIf(parent: any, model: any) {\n  parent.querySelectorAll('[x-if]').forEach((el:any) => {\n    const key = el.getAttribute('x-if');\n    const placeholder = document.createComment(`x-if=\"${key}\"`);\n    el.parentNode.insertBefore(placeholder, el);\n    el.parentNode.removeChild(el);  // Usuwamy oryginalny element (z dyrektywą `x-if`)\n\n    const updateVisibility = () => {\n      if (model[key]) {\n        if (!el.parentNode) {\n          placeholder.parentNode?.insertBefore(el, placeholder.nextSibling);  // Wstawiamy element\n        }\n      } else {\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);  // Usuwamy element\n        }\n      }\n    };\n\n    updateVisibility();\n\n    // Zmiana w modelu, zaktualizuj widoczność\n    Object.defineProperty(model, key, {\n      get: function () {\n        return this[`_${key}`];\n      },\n      set: function (value: any) {\n        this[`_${key}`] = value;\n        updateVisibility();  // Zaktualizuj widoczność po zmianie wartości\n      },\n    });\n  });\n}\n\nexport {handleXIf};\n","import {handleXFor} from '../features/x-for';\nimport {handleXIf} from '../features/x-if';\nimport {bindModelToTextContent} from './bind-text';\nimport {getNestedValue, setNestedValue} from './nested-value';\n\n/**\n *\n * @param model\n * @param {any} parent\n */\nfunction bindElements(model:any, parent: any = document) {\n  // Obsługa dyrektywy `x-if`\n  handleXIf(parent, model);\n\n  // Obsługa dyrektywy `x-for`\n  handleXFor(parent, model);\n\n  // Obsługa bindowania inputów\n  parent.querySelectorAll('[x-model]').forEach((el:any) => {\n    const key = el.getAttribute('x-model');\n    const value = getNestedValue(model, key);\n\n    // Ustawienie początkowej wartości\n    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {\n      el.value = value || '';\n    } else {\n      el.textContent = value || '';\n    }\n\n    // Nasłuchiwanie na zmiany w polach formularza\n    el.addEventListener('input', (e:any) => {\n      const newValue = e.target.value;\n      setNestedValue(model, key, newValue); // Aktualizacja zagnieżdżonej wartości w modelu\n    });\n  });\n\n  // Obsługa tekstu dynamicznego\n  bindModelToTextContent(model);\n}\n\nexport {bindElements};\n","import {bindElements} from './bindings/bind-elements';\nimport {reactive} from './reactive-handler';\n\nfunction appX(data: any) {\n  const model = reactive(data);\n  bindElements(model);\n}\n\nexport {appX};\n"],"names":["getBindMethod","proxy","bindings","key","element","getNestedValue","model","path","acc","part","setNestedValue","value","parts","current","lastKey","bindModelToTextContent","el","getBindTextMethod","textBindings","xModelAttr","originalText","matches","updateText","_","match","reactive","data","handler","target","success","nestedKeys","nestedModel","i","nestedKey","handleXFor","parent","expression","itemKey","arrayKey","str","placeholder","items","nextNode","currentNode","item","localModel","clone","_a","bindElements","handleXIf","updateVisibility","e","newValue","appX"],"mappings":"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"}