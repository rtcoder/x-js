{"version":3,"file":"index.es.js","sources":["../src/bindings/bind.ts","../src/bindings/nested-value.ts","../src/bindings/bind-text.ts","../src/reactive-handler.ts","../src/features/x-for.ts","../src/features/x-if.ts","../src/bindings/bind-elements.ts","../src/main.ts"],"sourcesContent":["/**\n *\n * @param {object} proxy\n * @param {Map} bindings\n * @return {(function(key:string, element:HTMLElement): void)}\n */\nfunction getBindMethod(proxy: any, bindings: Map<any, any>) {\n  /**\n   * @property {string} key\n   * @property {HTMLElement} element\n   */\n  return (key:string, element:any) => {\n    if (!bindings.has(key)) {\n      bindings.set(key, []);\n    }\n    bindings.get(key).push(element);\n\n    // Synchronizacja początkowa\n    if (element.type === 'checkbox') {\n      element.checked = proxy[key];\n    } else if (element.type === 'radio') {\n      element.checked = element.value === proxy[key];\n    } else {\n      element.value = proxy[key];\n    }\n\n    // DOM to model\n    element.addEventListener('input', () => {\n      if (element.type === 'checkbox') {\n        proxy[key] = element.checked;\n      } else if (element.type === 'radio') {\n        if (element.checked) proxy[key] = element.value;\n      } else {\n        proxy[key] = element.value;\n      }\n    });\n\n    // Obsługa select\n    if (element.tagName === 'SELECT') {\n      element.addEventListener('change', () => {\n        proxy[key] = element.value;\n      });\n    }\n  };\n}\n\nexport {getBindMethod};\n","import {bindModelToTextContent} from './bind-text';\n\nfunction getNestedValue(model:any, path:string) {\n  return path.split('.').reduce((acc, part) => acc && acc[part], model);\n}\n\nfunction setNestedValue(model:any, path:string, value:any) {\n  const parts = path.split('.');\n  let current = model;\n\n  // Idziemy do ostatniego elementu w ścieżce\n  for (let i = 0; i < parts.length - 1; i++) {\n    current = current[parts[i]];  // Przechodzimy po zagnieżdżonych obiektach\n  }\n\n  // Teraz aktualizujemy wartość właściwości w ostatnim obiekcie\n  const lastKey = parts[parts.length - 1];\n  if (current) {\n    current[lastKey] = value;\n    model[lastKey] = value;\n  }\n\n  bindModelToTextContent(model);\n}\n\nexport {getNestedValue, setNestedValue};\n","import {getNestedValue} from './nested-value';\n\nfunction bindModelToTextContent(model:any) {\n  document.querySelectorAll('*').forEach((el) => {\n    if (el.tagName === 'SCRIPT') {\n      return;\n    }\n    if (el.childNodes.length === 1 && el.childNodes[0].nodeType === Node.TEXT_NODE) {\n      model.bindText(el);\n    }\n  });\n}\n\n/**\n *\n * @param {object} proxy\n * @param {Map} textBindings\n * @return {(function(el:HTMLElement): void)}\n */\nfunction getBindTextMethod(proxy:any, textBindings:Map<any, any>) {\n  /**\n   * @property {HTMLElement} el\n   */\n  return (el:any) => {\n    const xModelAttr = el.getAttribute('x-model');\n    if (!xModelAttr) {\n      if (!el.dataset.originalContent) {\n        el.dataset.originalContent = el.textContent;\n      }\n    } else {\n      el.dataset.originalContent = `{${xModelAttr}}`;\n    }\n    const originalText = el.dataset.originalContent;\n\n    // Szukaj wzorców {key}\n    const matches = originalText.match(/{\\s*[\\w.]+\\s*}/g);\n    if (matches) {\n      const updateText = () => {\n        // Aktualizujemy tekst, uwzględniając zagnieżdżone właściwości\n        el.textContent = originalText.replace(/{\\s*([\\w.]+)\\s*}/g, (_:string, key:string) => {\n          return getNestedValue(proxy, key.trim()) || '';\n        });\n      };\n\n      // Zarejestruj każdą kluczową właściwość\n      matches.forEach((match:string) => {\n        const key = match.replace(/[{}]/g, '').trim();\n        if (!textBindings.has(key)) {\n          textBindings.set(key, []);\n        }\n        textBindings.get(key).push(updateText);\n      });\n      updateText();\n    }\n  };\n}\n\nexport {getBindTextMethod, bindModelToTextContent};\n","import {getBindMethod} from './bindings/bind';\nimport {getBindTextMethod} from './bindings/bind-text';\n\n/**\n *\n * @param {object} data\n * @return {object|any|boolean}\n */\nfunction reactive(data: any) {\n  const bindings = new Map(); // Powiązania inputów\n  const textBindings = new Map(); // Powiązania tekstów w DOM\n\n  const handler = {\n    get(target: any, key: any) {\n      return Reflect.get(target, key);\n    },\n    set(target: any, key: any, value: any) {\n      const success = Reflect.set(target, key, value);\n\n      // Zaktualizuj powiązane inputy\n      if (bindings.has(key)) {\n        bindings.get(key).forEach((el: any) => {\n          if (el.type === 'checkbox') {\n            el.checked = value;\n          } else if (el.type === 'radio') {\n            el.checked = el.value === value;\n          } else {\n            el.value = value;\n          }\n        });\n      }\n\n      // Zaktualizuj powiązane teksty\n      if (textBindings.has(key)) {\n        textBindings.get(key).forEach((updateText: any) => updateText());\n      }\n\n      // Sprawdź zagnieżdżone obiekty i aktualizuj je w razie potrzeby\n      if (key.includes('.')) {\n        const nestedKeys = key.split('.');\n        let nestedModel = target;\n        for (let i = 0; i < nestedKeys.length - 1; i++) {\n          nestedModel = nestedModel[nestedKeys[i]];\n        }\n        const nestedKey = nestedKeys[nestedKeys.length - 1];\n        if (nestedModel && nestedModel.hasOwnProperty(nestedKey)) {\n          nestedModel[nestedKey] = value;\n        }\n      }\n\n      return success;\n    },\n  };\n\n  const proxy = new Proxy(data, handler);\n\n  proxy.bind = getBindMethod(proxy, bindings);\n  proxy.bindText = getBindTextMethod(proxy, textBindings);\n\n  return proxy;\n}\n\nexport {reactive};\n","import {bindElements} from '../bindings/bind-elements.ts';\nimport {reactive} from '../reactive-handler';\n\n/**\n *\n * @param {Document|HTMLElement} parent\n * @param model\n * @return void\n */\nfunction handleXFor(parent:any, model:any) {\n  parent.querySelectorAll('[x-for]').forEach((el:any) => {\n    const expression = el.getAttribute('x-for');\n    const [itemKey, arrayKey] = expression.split(' in ').map((str:string) => str.trim());\n    const placeholder = document.createComment(`x-for=\"${expression}\"`);\n    el.parentNode.insertBefore(placeholder, el);\n    el.parentNode.removeChild(el);\n\n    const updateList = () => {\n      const items = model[arrayKey] || [];\n\n      // Usuwamy poprzednie elementy (poza placeholderem)\n      let nextNode = placeholder.nextSibling;\n      while (nextNode && nextNode.nodeType !== Node.COMMENT_NODE) {\n        const currentNode = nextNode;\n        nextNode = currentNode.nextSibling;\n        currentNode.remove();\n      }\n\n      // Renderujemy elementy w porządku tablicy\n      items.forEach((item:any) => {\n        const localModel = reactive({[itemKey]: item});\n        const clone = el.cloneNode(true);  // Tworzymy nową kopię elementu\n        clone.removeAttribute('x-for');  // Usuwamy atrybut x-for\n\n        // Wstawiamy elementy w odpowiedniej kolejności\n        placeholder.parentNode?.appendChild(clone);\n\n        // Bindowanie modelu dla każdego elementu\n        bindElements(localModel, placeholder.parentNode);\n      });\n    };\n\n    updateList();\n  });\n}\n\nexport {handleXFor};\n","/**\n *\n * @param {Document|HTMLElement} parent\n * @param model\n * @return void\n */\nfunction handleXIf(parent: any, model: any) {\n  parent.querySelectorAll('[x-if]').forEach((el:any) => {\n    const key = el.getAttribute('x-if');\n    const placeholder = document.createComment(`x-if=\"${key}\"`);\n    el.parentNode.insertBefore(placeholder, el);\n    el.parentNode.removeChild(el);  // Usuwamy oryginalny element (z dyrektywą `x-if`)\n\n    const updateVisibility = () => {\n      if (model[key]) {\n        if (!el.parentNode) {\n          placeholder.parentNode?.insertBefore(el, placeholder.nextSibling);  // Wstawiamy element\n        }\n      } else {\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);  // Usuwamy element\n        }\n      }\n    };\n\n    updateVisibility();\n\n    // Zmiana w modelu, zaktualizuj widoczność\n    Object.defineProperty(model, key, {\n      get: function () {\n        return this[`_${key}`];\n      },\n      set: function (value: any) {\n        this[`_${key}`] = value;\n        updateVisibility();  // Zaktualizuj widoczność po zmianie wartości\n      },\n    });\n  });\n}\n\nexport {handleXIf};\n","import {handleXFor} from '../features/x-for';\nimport {handleXIf} from '../features/x-if';\nimport {bindModelToTextContent} from './bind-text';\nimport {getNestedValue, setNestedValue} from './nested-value';\n\n/**\n *\n * @param model\n * @param {any} parent\n */\nfunction bindElements(model:any, parent: any = document) {\n  // Obsługa dyrektywy `x-if`\n  handleXIf(parent, model);\n\n  // Obsługa dyrektywy `x-for`\n  handleXFor(parent, model);\n\n  // Obsługa bindowania inputów\n  parent.querySelectorAll('[x-model]').forEach((el:any) => {\n    const key = el.getAttribute('x-model');\n    const value = getNestedValue(model, key);\n\n    // Ustawienie początkowej wartości\n    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {\n      el.value = value || '';\n    } else {\n      el.textContent = value || '';\n    }\n\n    // Nasłuchiwanie na zmiany w polach formularza\n    el.addEventListener('input', (e:any) => {\n      const newValue = e.target.value;\n      setNestedValue(model, key, newValue); // Aktualizacja zagnieżdżonej wartości w modelu\n    });\n  });\n\n  // Obsługa tekstu dynamicznego\n  bindModelToTextContent(model);\n}\n\nexport {bindElements};\n","import {bindElements} from './bindings/bind-elements';\nimport {reactive} from './reactive-handler';\n\nfunction appX(data: any) {\n  const model = reactive(data);\n  bindElements(model);\n}\n\nexport {appX};\n"],"names":["getBindMethod","proxy","bindings","key","element","getNestedValue","model","path","acc","part","setNestedValue","value","parts","current","lastKey","bindModelToTextContent","el","getBindTextMethod","textBindings","xModelAttr","originalText","matches","updateText","_","match","reactive","data","handler","target","success","nestedKeys","nestedModel","i","nestedKey","handleXFor","parent","expression","itemKey","arrayKey","str","placeholder","items","nextNode","currentNode","item","_a","localModel","clone","bindElements","handleXIf","updateVisibility","e","newValue","appX"],"mappings":"AAMA,SAASA,EAAcC,GAAYC,GAAyB;AAKnD,SAAA,CAACC,GAAYC,MAAgB;AAClC,IAAKF,EAAS,IAAIC,CAAG,KACVD,EAAA,IAAIC,GAAK,EAAE,GAEtBD,EAAS,IAAIC,CAAG,EAAE,KAAKC,CAAO,GAG1BA,EAAQ,SAAS,aACXA,EAAA,UAAUH,EAAME,CAAG,IAClBC,EAAQ,SAAS,UAC1BA,EAAQ,UAAUA,EAAQ,UAAUH,EAAME,CAAG,IAErCC,EAAA,QAAQH,EAAME,CAAG,GAInBC,EAAA,iBAAiB,SAAS,MAAM;AAClC,MAAAA,EAAQ,SAAS,aACbH,EAAAE,CAAG,IAAIC,EAAQ,UACZA,EAAQ,SAAS,UACtBA,EAAQ,YAAeH,EAAAE,CAAG,IAAIC,EAAQ,SAEpCH,EAAAE,CAAG,IAAIC,EAAQ;AAAA,IACvB,CACD,GAGGA,EAAQ,YAAY,YACdA,EAAA,iBAAiB,UAAU,MAAM;AACjC,MAAAH,EAAAE,CAAG,IAAIC,EAAQ;AAAA,IAAA,CACtB;AAAA,EAEL;AACF;AC1CA,SAASC,EAAeC,GAAWC,GAAa;AAC9C,SAAOA,EAAK,MAAM,GAAG,EAAE,OAAO,CAACC,GAAKC,MAASD,KAAOA,EAAIC,CAAI,GAAGH,CAAK;AACtE;AAEA,SAASI,EAAeJ,GAAWC,GAAaI,GAAW;AACnD,QAAAC,IAAQL,EAAK,MAAM,GAAG;AAC5B,MAAIM,IAAUP;AAGd,WAAS,IAAI,GAAG,IAAIM,EAAM,SAAS,GAAG;AAC1B,IAAAC,IAAAA,EAAQD,EAAM,CAAC,CAAC;AAI5B,QAAME,IAAUF,EAAMA,EAAM,SAAS,CAAC;AACtC,EAAIC,MACFA,EAAQC,CAAO,IAAIH,GACnBL,EAAMQ,CAAO,IAAIH,IAGnBI,EAAuBT,CAAK;AAC9B;ACrBA,SAASS,EAAuBT,GAAW;AACzC,WAAS,iBAAiB,GAAG,EAAE,QAAQ,CAACU,MAAO;AACzC,IAAAA,EAAG,YAAY,YAGfA,EAAG,WAAW,WAAW,KAAKA,EAAG,WAAW,CAAC,EAAE,aAAa,KAAK,aACnEV,EAAM,SAASU,CAAE;AAAA,EACnB,CACD;AACH;AAQA,SAASC,EAAkBhB,GAAWiB,GAA4B;AAIhE,SAAO,CAACF,MAAW;AACX,UAAAG,IAAaH,EAAG,aAAa,SAAS;AAC5C,IAAKG,IAKAH,EAAA,QAAQ,kBAAkB,IAAIG,CAAU,MAJtCH,EAAG,QAAQ,oBACXA,EAAA,QAAQ,kBAAkBA,EAAG;AAK9B,UAAAI,IAAeJ,EAAG,QAAQ,iBAG1BK,IAAUD,EAAa,MAAM,iBAAiB;AACpD,QAAIC,GAAS;AACX,YAAMC,IAAa,MAAM;AAEvB,QAAAN,EAAG,cAAcI,EAAa,QAAQ,qBAAqB,CAACG,GAAUpB,MAC7DE,EAAeJ,GAAOE,EAAI,KAAA,CAAM,KAAK,EAC7C;AAAA,MACH;AAGQ,MAAAkB,EAAA,QAAQ,CAACG,MAAiB;AAChC,cAAMrB,IAAMqB,EAAM,QAAQ,SAAS,EAAE,EAAE,KAAK;AAC5C,QAAKN,EAAa,IAAIf,CAAG,KACVe,EAAA,IAAIf,GAAK,EAAE,GAE1Be,EAAa,IAAIf,CAAG,EAAE,KAAKmB,CAAU;AAAA,MAAA,CACtC,GACUA,EAAA;AAAA,IAAA;AAAA,EAEf;AACF;AC/CA,SAASG,EAASC,GAAW;AACrB,QAAAxB,wBAAe,IAAI,GACnBgB,wBAAmB,IAAI,GAEvBS,IAAU;AAAA,IACd,IAAIC,GAAazB,GAAU;AAClB,aAAA,QAAQ,IAAIyB,GAAQzB,CAAG;AAAA,IAChC;AAAA,IACA,IAAIyB,GAAazB,GAAUQ,GAAY;AACrC,YAAMkB,IAAU,QAAQ,IAAID,GAAQzB,GAAKQ,CAAK;AAqB1C,UAlBAT,EAAS,IAAIC,CAAG,KAClBD,EAAS,IAAIC,CAAG,EAAE,QAAQ,CAACa,MAAY;AACjC,QAAAA,EAAG,SAAS,aACdA,EAAG,UAAUL,IACJK,EAAG,SAAS,UAClBA,EAAA,UAAUA,EAAG,UAAUL,IAE1BK,EAAG,QAAQL;AAAA,MACb,CACD,GAICO,EAAa,IAAIf,CAAG,KACtBe,EAAa,IAAIf,CAAG,EAAE,QAAQ,CAACmB,MAAoBA,GAAY,GAI7DnB,EAAI,SAAS,GAAG,GAAG;AACf,cAAA2B,IAAa3B,EAAI,MAAM,GAAG;AAChC,YAAI4B,IAAcH;AAClB,iBAASI,IAAI,GAAGA,IAAIF,EAAW,SAAS,GAAGE;AAC3B,UAAAD,IAAAA,EAAYD,EAAWE,CAAC,CAAC;AAEzC,cAAMC,IAAYH,EAAWA,EAAW,SAAS,CAAC;AAClD,QAAIC,KAAeA,EAAY,eAAeE,CAAS,MACrDF,EAAYE,CAAS,IAAItB;AAAA,MAC3B;AAGK,aAAAkB;AAAA,IAAA;AAAA,EAEX,GAEM5B,IAAQ,IAAI,MAAMyB,GAAMC,CAAO;AAE/B,SAAA1B,EAAA,OAAOD,EAAcC,GAAOC,CAAQ,GACpCD,EAAA,WAAWgB,EAAkBhB,GAAOiB,CAAY,GAE/CjB;AACT;ACnDA,SAASiC,EAAWC,GAAY7B,GAAW;AACzC,EAAA6B,EAAO,iBAAiB,SAAS,EAAE,QAAQ,CAACnB,MAAW;AAC/C,UAAAoB,IAAapB,EAAG,aAAa,OAAO,GACpC,CAACqB,GAASC,CAAQ,IAAIF,EAAW,MAAM,MAAM,EAAE,IAAI,CAACG,MAAeA,EAAI,MAAM,GAC7EC,IAAc,SAAS,cAAc,UAAUJ,CAAU,GAAG;AAC/D,IAAApB,EAAA,WAAW,aAAawB,GAAaxB,CAAE,GACvCA,EAAA,WAAW,YAAYA,CAAE,IAET,MAAM;AACvB,YAAMyB,IAAQnC,EAAMgC,CAAQ,KAAK,CAAC;AAGlC,UAAII,IAAWF,EAAY;AAC3B,aAAOE,KAAYA,EAAS,aAAa,KAAK,gBAAc;AAC1D,cAAMC,IAAcD;AACpB,QAAAA,IAAWC,EAAY,aACvBA,EAAY,OAAO;AAAA,MAAA;AAIf,MAAAF,EAAA,QAAQ,CAACG,MAAa;AJvBlC,YAAAC;AIwBQ,cAAMC,IAAarB,EAAS,EAAC,CAACY,CAAO,GAAGO,GAAK,GACvCG,IAAQ/B,EAAG,UAAU,EAAI;AAC/B,QAAA+B,EAAM,gBAAgB,OAAO,IAGjBF,IAAAL,EAAA,eAAA,QAAAK,EAAY,YAAYE,IAGvBC,EAAAF,GAAYN,EAAY,UAAU;AAAA,MAAA,CAChD;AAAA,IACH,GAEW;AAAA,EAAA,CACZ;AACH;ACtCA,SAASS,EAAUd,GAAa7B,GAAY;AAC1C,EAAA6B,EAAO,iBAAiB,QAAQ,EAAE,QAAQ,CAACnB,MAAW;AAC9C,UAAAb,IAAMa,EAAG,aAAa,MAAM,GAC5BwB,IAAc,SAAS,cAAc,SAASrC,CAAG,GAAG;AACvD,IAAAa,EAAA,WAAW,aAAawB,GAAaxB,CAAE,GACvCA,EAAA,WAAW,YAAYA,CAAE;AAE5B,UAAMkC,IAAmB,MAAM;ALPnC,UAAAL;AKQU,MAAAvC,EAAMH,CAAG,IACNa,EAAG,eACN6B,IAAAL,EAAY,eAAZ,QAAAK,EAAwB,aAAa7B,GAAIwB,EAAY,eAGnDxB,EAAG,cACFA,EAAA,WAAW,YAAYA,CAAE;AAAA,IAGlC;AAEiB,IAAAkC,EAAA,GAGV,OAAA,eAAe5C,GAAOH,GAAK;AAAA,MAChC,KAAK,WAAY;AACR,eAAA,KAAK,IAAIA,CAAG,EAAE;AAAA,MACvB;AAAA,MACA,KAAK,SAAUQ,GAAY;AACpB,aAAA,IAAIR,CAAG,EAAE,IAAIQ,GACDuC,EAAA;AAAA,MAAA;AAAA,IACnB,CACD;AAAA,EAAA,CACF;AACH;AC5BA,SAASF,EAAa1C,GAAW6B,IAAc,UAAU;AAEvD,EAAAc,EAAUd,GAAQ7B,CAAK,GAGvB4B,EAAWC,GAAQ7B,CAAK,GAGxB6B,EAAO,iBAAiB,WAAW,EAAE,QAAQ,CAACnB,MAAW;AACjD,UAAAb,IAAMa,EAAG,aAAa,SAAS,GAC/BL,IAAQN,EAAeC,GAAOH,CAAG;AAGvC,IAAIa,EAAG,YAAY,WAAWA,EAAG,YAAY,aAC3CA,EAAG,QAAQL,KAAS,KAEpBK,EAAG,cAAcL,KAAS,IAIzBK,EAAA,iBAAiB,SAAS,CAACmC,MAAU;AAChC,YAAAC,IAAWD,EAAE,OAAO;AACX,MAAAzC,EAAAJ,GAAOH,GAAKiD,CAAQ;AAAA,IAAA,CACpC;AAAA,EAAA,CACF,GAGDrC,EAAuBT,CAAK;AAC9B;ACnCA,SAAS+C,EAAK3B,GAAW;AACjB,QAAApB,IAAQmB,EAASC,CAAI;AAC3B,EAAAsB,EAAa1C,CAAK;AACpB;"}